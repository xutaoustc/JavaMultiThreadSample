#Java multi-thread sample
同时开启多个线程是为了同时执行多部分代码。每一个线程都有自己运行的内容，这个内容可以称为线程要执行的任务
创建线程的目的是为了开启一条执行路径，去运行指定的代码和其他代码实现同时运行，而运行的指定代码就是这个执行路径的任务

主线程先结束了，程序不一定结束。只要有还在运行的线程，虚拟机就不会退出。

每个线程有自己的栈，线程之间相互不影响，哪个线程的任务执行完毕后哪个线程结束。
一般多个线程同时执行时，如果一个线程发生了异常，通常代表这个线程的代码执行的结束，但是这并不会影响到其他的线程，另外线程还会继续执行。


CPU执行资格：可以被CPU处理，在处理队列中排队
CPU执行权：正在被CPU处理
运行状态既具备着CPU执行资格又具备着CPU执行权
冻结状态释放执行资格的同时释放执行权
就绪状态具备执行资格，但是不具备执行权，正在等待执行权
就绪状态的线程是否能够执行取决于物理CPU的调度
                  *
                  *   
创建-----start()----->就绪<-----------------sleep()时间到-----冻结
|                 *   /\ <-----------------notify()-----------|       
|                 *   |                                       | 
|                 *   |                                       |  
|                 *   |                                       |
|                 *   |                                       |                     
|                 *   \/                                      |
|                 *  运行-----sleep()------------------------->|
|                 *   | ------------wait()------------------->|
|                 *   |                                       | 
|                 ****|***************************************|**************
|                     |                                       |
|                     |                                       |
|                   run()结束                                  |
|                    stop()                                   |
|                     |                                       |
|                     \/                                      |
---------stop()------>结束<------------------------------------|


class Thread
{
    private Runnable r;
    
    Thread(){
    }
    
    Thread(Runnable r){
        this.r=r;
    }
    
    public void run(){
        if(r!=null)
            r.run();
    }
    
    public void start(){
        run();
    }
}


线程间通讯和之前的例子不一样，之前的例子多个线程执行的是同一个东西，而线程间通讯多个线程执行的是不同的任务。但是处理的资源都是共享资源


wait释放锁，sleep不释放锁

注意，notify和notifyAll之后呢，所有的线程还是要抢锁的，并不存在不需要抢锁直接马上可以全部执行的现象，类似于所有的线程同时start然后开始抢锁一样。

线程组就是把批量的线程绑定到一起，可以一起操作，这样比较方便。

----------------------------------------------------------------------------------------------------------------------
i++不是一个原子操作  1.读取 2.运算 3.写入

有序性指的是线程间语句的执行顺序并不一定是按照语句申明的顺序来的，各种原因的优化都可能导致顺序的变更，作为单线程程序来说这是没有问题的，因为
指令重排的前提是不破坏语义，但是多于多线程来说，一个线程看另一个线程的执行顺序的时候会出现乱序的现象。

可见性问题指从一个线程中看另外一个线程变量的值，出现的不确定的现象，成因很多---
指令重排：因为不知道谁先谁后，所以没有办法去从另一个线程当中看另外一个线程去看一个变量运行到了什么程度，去推测另一个变量究竟是什么值。
编译器优化：
硬件优化：写吸收，批操作
虚拟机层面：






